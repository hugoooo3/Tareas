<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SGBD</title>
</head>

<body>
    <h1>¿QUE ES UN SGBD?</h1>
    <p>Un sistema gestor de base de datos o SGBD es un software que permite administrar una base de datos. Esto
        significa que mediante este programa se puede utilizar, configurar y extraer información almacenada​. Los
        usuarios pueden acceder a la información usando herramientas específicas de consulta y de generación de
        informes, o bien mediante aplicaciones al efecto.

        Estos sistemas también proporcionan métodos para mantener la integridad de los datos, para administrar el acceso
        de usuarios a los datos y para recuperar la información si fallo del sistema y hacer copias de seguridad. Las
        bases de datos y los sistemas para su gestión son esenciales para cualquier área de negocio, y deben ser
        gestionados con esmero.

        Algunos ejemplos de SGBD son MySQL, MariaDB, MongoDB, Microsoft SQL Server, Oracle Database y Microsoft
        Access.</p>
    <hr>
    <h2>HISTORIA</h2>
    <ol>
        <a href="#Sistemas de navegación (1960)">
            <li>Sistemas de navegación (1960)</li>
        </a>
        <a href="#Sistemas relacionales (1970)">
            <li>Sistemas relacionales (1970)</li>
        </a>
        <a href="#Sistemas SQL (finales de década de 1970)">
            <li>Sistemas SQL (finales de década de 1970)</li>
        </a>
        <a href="#Sistemas orientados a objetos (1980)">
            <li>Sistemas orientados a objetos (1980)</li>
        </a>
        <a href="#Sistemas NoSQL (2000)">
            <li>Sistemas NoSQL (2000)</li>
        </a>
        <a href="#Sistemas XML (2010)">
            <li>Sistemas XML (2010)</li>
        </a>
    </ol>
    <hr><br>
    <h3 id="Sistemas de navegación (1960)">1. Sistemas de navegación (1960)</h3>
    <p>Según las computadoras fueron ganando velocidad y capacidad, aparecieron sistemas de bases de datos de propósito
        general; a mediados de 1960 ya había algunos sistemas en uso. Apareció el interés en obtener un estándar y
        Charles Bachman —autor de uno de los primeros productos, el Integrated Data Store (IDS)— fundó el Database Task
        Group dentro de CODASYL, el grupo responsable de la creación y estandarización de COBOL. En 1971 publicaron su
        estándar, que pasó a ser conocido como la «aproximación CODASYL», y en breve aparecieron algunos productos
        basados en esta línea.<br>La estrategia de CODASYL estaba basada en la navegación manual por un conjunto de
        datos enlazados en red. Cuando se arrancaba la base de datos, el programa devolvía un enlace al primer registro
        de la base de datos, el cual a su vez contenía punteros a otros datos. Para encontrar un registro concreto el
        programador debía ir siguiendo punteros hasta llegar al registro buscado.
        <br>La estrategia de CODASYL estaba basada en la navegación manual por un conjunto de datos enlazados en red.
        Cuando se arrancaba la base de datos, el programa devolvía un enlace al primer registro de la base de datos, el
        cual a su vez contenía punteros a otros datos. Para encontrar un registro concreto el programador debía ir
        siguiendo punteros hasta llegar al registro buscado.
        <br>IBM también tenía su SGBD propio en 1968, conocido como IMS. Se trataba de un software desarrollado para el
        programa Apolo sobre System/360. IMS tenía conceptos similares a CODASYL, pero usaba una jerarquía estricta de
        ordenación de los datos, frente a la estructura en red de CODASYL. Ambos conceptos fueron englobados
        posteriormente en el concepto de bases de datos de navegación debido al modo de acceso a los datos, de hecho
        Bachman recibió al premio Turing en 1973 por su ponencia El programador como navegador.
    </p>
    <hr><br>
    <h3 id="Sistemas relacionales (1970)">2. Sistemas relacionales (1970)</h3>
    <p>Un uso común de las bases de datos puede mantener una agenda de usuarios, su nombre, información de acceso,
        dirección y teléfono. En la solución de navegación todos esos datos estaría localizados en un solo registro, y
        las características no usadas simplemente no estarían en la base de datos. En la solución relacional, los datos
        estarían normalizados en una tabla de usuario, una de teléfono y una de dirección, en la que serían añadidos
        registros si tuviéramos que incorporar teléfono y dirección.<br>Reconciliar toda la información es la clave de
        este sistema. En el modelo relacional, una parte de la información se usa como clave, identificando de manera
        biunívoca un registro concreto. Cuando se recopila información acerca de un usuario, se accederá a la
        información de las tablas optativas buscando mediante esa clave. Por ejemplo si el nombre de usuario es único,
        la dirección y número de teléfono de ese usuario será guardada con el nombre de usuario como clave. La
        recopilaciòn de esta información en un solo registro es algo para lo que los lenguajes tradicionales no están
        pensados.<br>Así como el enfoque de navegación requiere programas que realicen bucles para recolectar registros,
        el enfoque relacional también los requerirá. La solución de Codd para los necesarios bucles se basa en un
        lenguaje orientado a conjuntos, una sugerencia que más tarde cristalizaría en el ubicuo SQL. Planteó el uso de
        una rama del álgebra llamada cálculo de tuplas, y demostró que con ella se podrían realizar todas las
        operaciones típicas sobre una base de datos, además de extraer conjuntos de datos de una forma sencilla.<br>En
        la década de 1970, la Universidad de Míchigan comenzó el desarrollo del MICRO Information Management System
        basado en el modelo teórico de datos de D. L. Childs. Micro fue utilizado para gestionar gran cantidad de datos
        en el Departamento de Trabajo del gobierno de EUA. Corría en mainframe usando Michigan Terminal System. Estuvo
        en producción hasta 1998.
    </p>
    <hr><br>
    <h3 id="Sistemas SQL (finales de década de 1970)">3. Sistemas SQL (finales de década de 1970)</h3>
    <p>IBM empezó a trabajar a principios de 1970 en un prototipo lejanamente basado en los conceptos de Codd llamándolo
        System R. La primera versión estuvo lista en 1974 o 1975, y comenzó así el trabajo en sistemas multitabla, en
        los que los datos podían disgregarse de modo que toda la información de un registro no tiene que estar
        almacenada en un único trozo grande. Las versiones multiusuario siguientes fueron probadas por los usuarios en
        1978 y 1979, tiempo por el que un lenguaje SQL había sido estandarizado. Las ideas de Codd se revelaron como
        operativas y superiores a las de CODASYL, lanzando a IBM al desarrollo de una verdadera versión de producción de
        System R, conocido como SQL/DS, y posteriormente como Database 2 (DB2).<br>Muchos de los técnicos de INGRES
        estaban seguros del éxito comercial del sistema, y formaron sus propias compañías para comercializar el
        desarrollo pero con una interfaz SQL. Sybase, Informix, NonStop SQL y la misma INGRES se vendían como derivados
        del INGRES original en los años 1980. Incluso el SQL Server de Microsoft está basado en Sybase, y por
        consiguiente en INGRES. Solo Larry Ellison —el fundador de Oracle— comenzó un nuevo camino basado en el artículo
        de IBM sobre System R, y aventajó a IBM sacando al mercado su primera versión en 1978.<br>En 1984 este proyecto
        se consolidó en una compañía independiente. A principios de 1980, Mimer introdujo la gestión de transacciones
        para dar robustez a las aplicaciones, una idea que fue recogida en muchos otros SGBD.
    </p>
    <hr><br>
    <h3 id="Sistemas orientados a objetos (1980)">4. Sistemas orientados a objetos (1980)</h3>
    <p>Durante la década de 1980 el auge de la programación orientada a objetos influyó en el modo de manejar la
        información de las bases de datos. Programadores y diseñadores comenzaron a tratar los datos en las bases de
        datos como objetos. Esto quiere decir que si los datos de una persona están en la base de datos, los atributos
        de la persona como dirección, teléfono y edad se consideran que pertenecen a la persona, no son datos extraños.
        Esto permite establecer relaciones entre objetos y atributos, más que entre campos individuales.<br>Otro gran
        foco de atención durante la década fue el incremento de velocidad y fiabilidad en el acceso. En 1989, dos
        profesores de la Universidad de Wisconsin publicaron un artículo en una conferencia ACM en el que exponían sus
        métodos para mejorar las prestaciones de las bases de datos. La idea consistía en replicar la información
        importante —y más solicitada— en una base de datos temporal de pequeño tamaño con enlaces a la base de datos
        principal. Esto implicaba que se podía buscar mucho más rápido en la base de datos pequeña que en la grande. Su
        mejora de prestaciones llevó a la introducción de la indización, incorporado en la totalidad de los SGBD.
    </p>
    <hr><br>
    <h3 id="Sistemas NoSQL (2000)">5. Sistemas NoSQL (2000)</h3>
    <p>El siglo xxi trajo una nueva tendencia en las bases de datos: el NoSQL. Esta tendencia introducía una línea no
        relacional significativamente diferentes de las clásicas. No requieren por lo general esquemas fijos, evitan las
        operaciones join almacenando datos desnormalizados y están diseñadas para escalar horizontalmente. La mayor
        parte de ellas pueden clasificarse como almacenes clave-valor o bases de datos orientadas a
        documentos.<br>Recientemente ha habido una gran demanda de bases de datos distribuidas con tolerancia a
        particiones, pero de acuerdo con el teorema CAP no es posible conseguir un sistema distribuido que
        simultáneamente proporcione consistencia, disponibilidad y tolerancia al particionado. Un sistema distribuido
        puede satisfacer solo dos de las tres restricciones a la vez. Por dicha razón muchas de las bases de datos NoSQL
        usan la llamada consistencia eventual para proporcionar disponibilidad y tolerancia al particionado, con un
        nivel máximo de consistencia de datos.<br>
    </p>
    <hr><br>
    <h3 id="Sistemas XML (2010)">6. Sistemas XML (2010)</h3>
    <p>Las bases de datos XML forman un subconjunto de las bases de datos NoSQL. Todas ellas usan el formato de
        almacenamiento XML, que está abierto, legible por humanos y máquinas y ampliamente usado para interoperabilidad.
    </p>
    <hr><br>
    <h2>COMPONENTES</h2>
    <ol>
        <li>El motor de la base de datos acepta peticiones lógicas de los otros subsistemas del SGBD, las convierte en
            su equivalente físico y accede a la base de datos y diccionario de datos en el dispositivo de
            almacenamiento.</li>
        <br>
        <li>El subsistema de definición de datos ayuda a crear y mantener el diccionario de datos y define la estructura
            del fichero que soporta la base de datos.</li>
        <br>
        <li>El subsistema de manipulación de datos ayuda al usuario a añadir, cambiar y borrar información de la base de
            datos y la consulta para extraer información. El subsistema de manipulación de datos suele ser la interfaz
            principal del usuario con la base de datos. Permite al usuario especificar sus requisitos de la información
            desde un punto de vista lógico.</li>
        <br>
        <li>El subsistema de generación de aplicaciones contiene utilidades para ayudar a los usuarios en el desarrollo
            de aplicaciones. Usualmente proporciona pantallas de entrada de datos, lenguajes de programación e
            interfaces.</li>
        <br>
        <li>El subsistema de administración ayuda a gestionar la base de datos ofreciendo funcionalidades como
            almacenamiento y recuperación, gestión de la seguridad, optimización de preguntas, control de concurrencia y
            gestión de cambios.</li>
    </ol>
    <hr>
    <h2>CLASIFICACION SEGUN LA ESTRUCTURA</h2>
    <ol>
        <a href="#Estructura jerárquica">
            <li>Estructura jerárquica</li>
        </a>
        <a href="#Estructura en red">
            <li>Estructura en red</li>
        </a>
        <a href="#Estructura relacional">
            <li>Estructura relacional</li>
        </a>
        <a href="#Estructura multidimensional">
            <li>Estructura multidimensional</li>
        </a>
        <a href="#Estructura orientada a objetos">
            <li>Estructura orientada a objetos</li>
        </a>
    </ol>
    <hr>
    <h3 id="Estructura jerárquica">1. Estructura jerárquica</h3>
    <P>La estructura jerárquica fue usada en los SGBD de los primeros mainframe. Las relaciones entre registros forman
        una estructura en árbol. Esta estructura es simple pero inflexible ya que las relaciones están confinadas al
        tipo 1:n. El sistema IMS de IBM y el RDM Mobile de Raima​ son ejemplos de bases de datos con múltiples
        jerarquías sobre el mismo conjunto de datos. RDM Mobile es un nuevo diseño de base de datos imbuida para una red
        de ordenadores móviles. La estructura jerárquica es usada hoy en día para almacenar información geográfica
        principalmente.<br>El modelo de base de datos jerárquica tiene un esquema en el que los datos se organizan en
        una estructura arbórea. Esta estructura permite representar relaciones padre/hijo: cada padre puede tener varios
        hijos, pero cada hijo ha de venir de solo un padre (las conocidas como relaciones 1:N). Todos los atributos de
        un registro específico están asociados a un tipo de entidad. Este modelo fue creado por IBM en 1960.<br>En una
        base de datos una entidad tipo es el término genérico para tabla. Cada registro individual se representa como
        una fila, y cada atributo como una columna. Las entidades tipo se relacionan entre ellas usando correspondencias
        1:N.
    </P>
    <hr>
    <h3 id="Estructura en red">2. Estructura en red</h3>
    <p>Esta estructura contiene relaciones más complejas que las jerárquicas. Admite relaciones de cada registro con
        varios que se pueden seguir por distintos caminos. En otras palabras, el modelo permite relaciones N:N.<br>El
        modelo en red está concebido como un modo flexible de representar objetos y sus relaciones. Su cualidad
        distintiva es que el esquema —visto como un conjunto de nodos conectados por arcos— no tiene ninguna
        restricción.<br>El inventor de este modelo fue Charles Bachman, y el estándar fue publicado en 1969 por CODASYL.
    </p>
    <hr>
    <h3 id="Estructura relacional">3. Estructura relacional</h3>
    <p>La estructura relacional es la más extendida hoy en día. Se usa en mainframes, computadoras medias y
        microcomputadoras. Almacena los datos en filas (tuplas) y columnas (atributos). Estas tablas pueden estar
        conectadas entre sí por claves comunes. Mientras trabajaba en IBM en 1972, E. F. Codd concibió esta estructura.
        El modelo no resulta sencillo de consultar por el usuario ya que puede requerir una compleja combinación de
        tablas.
    </p>
    <hr>
    <h3 id="Estructura multidimensional">4. Estructura multidimensional</h3>
    <p>La estructura multidimensional tiene parecidos a la del modelo relacional, pero en vez de las dos dimensiones
        filas-columnas, tiene N dimensiones. Esta estructura ofrece el aspecto de una hoja de cálculo. Es fácil de
        mantener y entender ya que los registros se almacenan del mismo modo como se ven. Sus altas prestaciones han
        hecho de ella la base de datos más popular para el proceso analítico de transacciones en línea (OLAP).
    </p>
    <hr>
    <h3 id="Estructura orientada a objetos">5. Estructura orientada a objetos</h3>
    <p>La estructura orientada a objetos está diseñada siguiendo el paradigma de los lenguajes orientados a objetos. De
        este modo soporta los tipos de datos gráficos, imágenes, voz y texto de manera natural. Esta estructura tiene
        gran difusión en aplicaciones web para aplicaciones multimedia.<br>Antes de la implantación de los SGBD con
        estructura orientada a objetos, el almacenamiento de datos multimedia se basaba en el sistema de ficheros para
        organizar, almacenar y procesar los datos. El proceso de ficheros es engorroso, costoso e inflexible. La
        redundancia de los datos es un inconveniente del proceso de ficheros ya que los ficheros independientes producen
        ficheros duplicados con su implicación en el espacio necesario. Otro inconveniente es la falta de integración, y
        la dificultad de mantenimiento. Esto fue encaminado aplicando la orientación a objetos a los datos.
    </p>
    <hr>
    <a href="./páginas/MySQL.html">
        <h2>MySQL</h2>
    </a>
    <hr>
    <a href="./páginas/MariaDB.html">
        <h2>MariaDB</h2>
    </a>
    <hr>
    <a href="./páginas/MongoDB.html">
        <h2>MongoDB</h2>
    </a>
    <hr>
    <a href="./páginas/Microsoft Access.html">
        <h2>Microsoft Access</h2>
    </a>
    <hr>
    <a href="./páginas/Oracle Database.html">
        <h2>Oracle database</h2>
    </a>
    <hr>

















    <hr>
    <a href="mailto:hugo.largo@educa.madrid.org">hugo.largo@educa.madrid.org</a>
</body>

</html>
